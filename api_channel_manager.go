/*
Channel Manager Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
Contact: info@gemini-commerce.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package channelmanager

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type ChannelManagerAPI interface {

	/*
	ChannelManagerCreateAssociation CreateAssociation

	Create a new association between a channel and a market or entities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerCreateAssociationRequest
	*/
	ChannelManagerCreateAssociation(ctx context.Context) ChannelManagerAPIChannelManagerCreateAssociationRequest

	// ChannelManagerCreateAssociationExecute executes the request
	//  @return ChannelmanagerAssociationResponse
	ChannelManagerCreateAssociationExecute(r ChannelManagerAPIChannelManagerCreateAssociationRequest) (*ChannelmanagerAssociationResponse, *http.Response, error)

	/*
	ChannelManagerCreateChannel CreateChannel

	Create a new channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerCreateChannelRequest
	*/
	ChannelManagerCreateChannel(ctx context.Context) ChannelManagerAPIChannelManagerCreateChannelRequest

	// ChannelManagerCreateChannelExecute executes the request
	//  @return ChannelmanagerChannelResponse
	ChannelManagerCreateChannelExecute(r ChannelManagerAPIChannelManagerCreateChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error)

	/*
	ChannelManagerCreateMarket CreateMarket

	Create a new market

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerCreateMarketRequest
	*/
	ChannelManagerCreateMarket(ctx context.Context) ChannelManagerAPIChannelManagerCreateMarketRequest

	// ChannelManagerCreateMarketExecute executes the request
	//  @return ChannelmanagerMarketResponse
	ChannelManagerCreateMarketExecute(r ChannelManagerAPIChannelManagerCreateMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error)

	/*
	ChannelManagerDeleteAssociation DeleteAssociation

	Delete an existing association between a channel and a market or entities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerDeleteAssociationRequest
	*/
	ChannelManagerDeleteAssociation(ctx context.Context) ChannelManagerAPIChannelManagerDeleteAssociationRequest

	// ChannelManagerDeleteAssociationExecute executes the request
	//  @return map[string]interface{}
	ChannelManagerDeleteAssociationExecute(r ChannelManagerAPIChannelManagerDeleteAssociationRequest) (map[string]interface{}, *http.Response, error)

	/*
	ChannelManagerDeleteChannel DeleteChannel

	Soft delete an existing channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerDeleteChannelRequest
	*/
	ChannelManagerDeleteChannel(ctx context.Context) ChannelManagerAPIChannelManagerDeleteChannelRequest

	// ChannelManagerDeleteChannelExecute executes the request
	//  @return map[string]interface{}
	ChannelManagerDeleteChannelExecute(r ChannelManagerAPIChannelManagerDeleteChannelRequest) (map[string]interface{}, *http.Response, error)

	/*
	ChannelManagerDeleteMarket DeleteMarket

	Soft delete an existing market

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerDeleteMarketRequest
	*/
	ChannelManagerDeleteMarket(ctx context.Context) ChannelManagerAPIChannelManagerDeleteMarketRequest

	// ChannelManagerDeleteMarketExecute executes the request
	//  @return map[string]interface{}
	ChannelManagerDeleteMarketExecute(r ChannelManagerAPIChannelManagerDeleteMarketRequest) (map[string]interface{}, *http.Response, error)

	/*
	ChannelManagerGetChannel GetChannel

	Get an existing channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerGetChannelRequest
	*/
	ChannelManagerGetChannel(ctx context.Context) ChannelManagerAPIChannelManagerGetChannelRequest

	// ChannelManagerGetChannelExecute executes the request
	//  @return ChannelmanagerChannelResponse
	ChannelManagerGetChannelExecute(r ChannelManagerAPIChannelManagerGetChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error)

	/*
	ChannelManagerGetChannelWithAssociations GetChannelWithAssociations

	Get an existing channel with associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest
	*/
	ChannelManagerGetChannelWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest

	// ChannelManagerGetChannelWithAssociationsExecute executes the request
	//  @return ChannelmanagerChannelResponseWithAssociations
	ChannelManagerGetChannelWithAssociationsExecute(r ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest) (*ChannelmanagerChannelResponseWithAssociations, *http.Response, error)

	/*
	ChannelManagerGetMarket GetMarket

	Get an existing market

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerGetMarketRequest
	*/
	ChannelManagerGetMarket(ctx context.Context) ChannelManagerAPIChannelManagerGetMarketRequest

	// ChannelManagerGetMarketExecute executes the request
	//  @return ChannelmanagerMarketResponse
	ChannelManagerGetMarketExecute(r ChannelManagerAPIChannelManagerGetMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error)

	/*
	ChannelManagerGetMarketWithAssociations GetMarketWithAssociations

	Get an existing market with associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest
	*/
	ChannelManagerGetMarketWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest

	// ChannelManagerGetMarketWithAssociationsExecute executes the request
	//  @return ChannelmanagerMarketResponseWithAssociations
	ChannelManagerGetMarketWithAssociationsExecute(r ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest) (*ChannelmanagerMarketResponseWithAssociations, *http.Response, error)

	/*
	ChannelManagerListChannels ListChannels

	List all channels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerListChannelsRequest
	*/
	ChannelManagerListChannels(ctx context.Context) ChannelManagerAPIChannelManagerListChannelsRequest

	// ChannelManagerListChannelsExecute executes the request
	//  @return ChannelmanagerListChannelsResponse
	ChannelManagerListChannelsExecute(r ChannelManagerAPIChannelManagerListChannelsRequest) (*ChannelmanagerListChannelsResponse, *http.Response, error)

	/*
	ChannelManagerListChannelsWithAssociations ListChannelsWithAssociations

	List all channels with associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest
	*/
	ChannelManagerListChannelsWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest

	// ChannelManagerListChannelsWithAssociationsExecute executes the request
	//  @return ChannelmanagerListChannelsWithAssociationsResponse
	ChannelManagerListChannelsWithAssociationsExecute(r ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest) (*ChannelmanagerListChannelsWithAssociationsResponse, *http.Response, error)

	/*
	ChannelManagerListMarkets ListMarkets

	List all markets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerListMarketsRequest
	*/
	ChannelManagerListMarkets(ctx context.Context) ChannelManagerAPIChannelManagerListMarketsRequest

	// ChannelManagerListMarketsExecute executes the request
	//  @return ChannelmanagerListMarketsResponse
	ChannelManagerListMarketsExecute(r ChannelManagerAPIChannelManagerListMarketsRequest) (*ChannelmanagerListMarketsResponse, *http.Response, error)

	/*
	ChannelManagerListMarketsWithAssociations ListMarketsWithAssociations

	List all markets with associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest
	*/
	ChannelManagerListMarketsWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest

	// ChannelManagerListMarketsWithAssociationsExecute executes the request
	//  @return ChannelmanagerListMarketsWithAssociationsResponse
	ChannelManagerListMarketsWithAssociationsExecute(r ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest) (*ChannelmanagerListMarketsWithAssociationsResponse, *http.Response, error)

	/*
	ChannelManagerUpdateChannel UpdateChannel

	Update an existing channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerUpdateChannelRequest
	*/
	ChannelManagerUpdateChannel(ctx context.Context) ChannelManagerAPIChannelManagerUpdateChannelRequest

	// ChannelManagerUpdateChannelExecute executes the request
	//  @return ChannelmanagerChannelResponse
	ChannelManagerUpdateChannelExecute(r ChannelManagerAPIChannelManagerUpdateChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error)

	/*
	ChannelManagerUpdateMarket UpdateMarket

	Update an existing market

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ChannelManagerAPIChannelManagerUpdateMarketRequest
	*/
	ChannelManagerUpdateMarket(ctx context.Context) ChannelManagerAPIChannelManagerUpdateMarketRequest

	// ChannelManagerUpdateMarketExecute executes the request
	//  @return ChannelmanagerMarketResponse
	ChannelManagerUpdateMarketExecute(r ChannelManagerAPIChannelManagerUpdateMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error)
}

// ChannelManagerAPIService ChannelManagerAPI service
type ChannelManagerAPIService service

type ChannelManagerAPIChannelManagerCreateAssociationRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerCreateAssociationRequest
}

func (r ChannelManagerAPIChannelManagerCreateAssociationRequest) Body(body ChannelmanagerCreateAssociationRequest) ChannelManagerAPIChannelManagerCreateAssociationRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerCreateAssociationRequest) Execute() (*ChannelmanagerAssociationResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerCreateAssociationExecute(r)
}

/*
ChannelManagerCreateAssociation CreateAssociation

Create a new association between a channel and a market or entities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerCreateAssociationRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerCreateAssociation(ctx context.Context) ChannelManagerAPIChannelManagerCreateAssociationRequest {
	return ChannelManagerAPIChannelManagerCreateAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerAssociationResponse
func (a *ChannelManagerAPIService) ChannelManagerCreateAssociationExecute(r ChannelManagerAPIChannelManagerCreateAssociationRequest) (*ChannelmanagerAssociationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerAssociationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerCreateAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/CreateAssociation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerCreateChannelRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerCreateChannelRequest
}

func (r ChannelManagerAPIChannelManagerCreateChannelRequest) Body(body ChannelmanagerCreateChannelRequest) ChannelManagerAPIChannelManagerCreateChannelRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerCreateChannelRequest) Execute() (*ChannelmanagerChannelResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerCreateChannelExecute(r)
}

/*
ChannelManagerCreateChannel CreateChannel

Create a new channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerCreateChannelRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerCreateChannel(ctx context.Context) ChannelManagerAPIChannelManagerCreateChannelRequest {
	return ChannelManagerAPIChannelManagerCreateChannelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerChannelResponse
func (a *ChannelManagerAPIService) ChannelManagerCreateChannelExecute(r ChannelManagerAPIChannelManagerCreateChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerChannelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerCreateChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/CreateChannel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerCreateMarketRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerCreateMarketRequest
}

func (r ChannelManagerAPIChannelManagerCreateMarketRequest) Body(body ChannelmanagerCreateMarketRequest) ChannelManagerAPIChannelManagerCreateMarketRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerCreateMarketRequest) Execute() (*ChannelmanagerMarketResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerCreateMarketExecute(r)
}

/*
ChannelManagerCreateMarket CreateMarket

Create a new market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerCreateMarketRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerCreateMarket(ctx context.Context) ChannelManagerAPIChannelManagerCreateMarketRequest {
	return ChannelManagerAPIChannelManagerCreateMarketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerMarketResponse
func (a *ChannelManagerAPIService) ChannelManagerCreateMarketExecute(r ChannelManagerAPIChannelManagerCreateMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerCreateMarket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/CreateMarket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerDeleteAssociationRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerDeleteAssociationRequest
}

func (r ChannelManagerAPIChannelManagerDeleteAssociationRequest) Body(body ChannelmanagerDeleteAssociationRequest) ChannelManagerAPIChannelManagerDeleteAssociationRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerDeleteAssociationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChannelManagerDeleteAssociationExecute(r)
}

/*
ChannelManagerDeleteAssociation DeleteAssociation

Delete an existing association between a channel and a market or entities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerDeleteAssociationRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerDeleteAssociation(ctx context.Context) ChannelManagerAPIChannelManagerDeleteAssociationRequest {
	return ChannelManagerAPIChannelManagerDeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ChannelManagerAPIService) ChannelManagerDeleteAssociationExecute(r ChannelManagerAPIChannelManagerDeleteAssociationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerDeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/DeleteAssociation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerDeleteChannelRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerDeleteChannelRequest
}

func (r ChannelManagerAPIChannelManagerDeleteChannelRequest) Body(body ChannelmanagerDeleteChannelRequest) ChannelManagerAPIChannelManagerDeleteChannelRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerDeleteChannelRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChannelManagerDeleteChannelExecute(r)
}

/*
ChannelManagerDeleteChannel DeleteChannel

Soft delete an existing channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerDeleteChannelRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerDeleteChannel(ctx context.Context) ChannelManagerAPIChannelManagerDeleteChannelRequest {
	return ChannelManagerAPIChannelManagerDeleteChannelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ChannelManagerAPIService) ChannelManagerDeleteChannelExecute(r ChannelManagerAPIChannelManagerDeleteChannelRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerDeleteChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/DeleteChannel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerDeleteMarketRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerDeleteMarketRequest
}

func (r ChannelManagerAPIChannelManagerDeleteMarketRequest) Body(body ChannelmanagerDeleteMarketRequest) ChannelManagerAPIChannelManagerDeleteMarketRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerDeleteMarketRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChannelManagerDeleteMarketExecute(r)
}

/*
ChannelManagerDeleteMarket DeleteMarket

Soft delete an existing market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerDeleteMarketRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerDeleteMarket(ctx context.Context) ChannelManagerAPIChannelManagerDeleteMarketRequest {
	return ChannelManagerAPIChannelManagerDeleteMarketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ChannelManagerAPIService) ChannelManagerDeleteMarketExecute(r ChannelManagerAPIChannelManagerDeleteMarketRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerDeleteMarket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/DeleteMarket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerGetChannelRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerGetChannelRequest
}

func (r ChannelManagerAPIChannelManagerGetChannelRequest) Body(body ChannelmanagerGetChannelRequest) ChannelManagerAPIChannelManagerGetChannelRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerGetChannelRequest) Execute() (*ChannelmanagerChannelResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerGetChannelExecute(r)
}

/*
ChannelManagerGetChannel GetChannel

Get an existing channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerGetChannelRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerGetChannel(ctx context.Context) ChannelManagerAPIChannelManagerGetChannelRequest {
	return ChannelManagerAPIChannelManagerGetChannelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerChannelResponse
func (a *ChannelManagerAPIService) ChannelManagerGetChannelExecute(r ChannelManagerAPIChannelManagerGetChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerChannelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerGetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/GetChannel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerGetChannelWithAssociationsRequest
}

func (r ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest) Body(body ChannelmanagerGetChannelWithAssociationsRequest) ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest) Execute() (*ChannelmanagerChannelResponseWithAssociations, *http.Response, error) {
	return r.ApiService.ChannelManagerGetChannelWithAssociationsExecute(r)
}

/*
ChannelManagerGetChannelWithAssociations GetChannelWithAssociations

Get an existing channel with associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerGetChannelWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest {
	return ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerChannelResponseWithAssociations
func (a *ChannelManagerAPIService) ChannelManagerGetChannelWithAssociationsExecute(r ChannelManagerAPIChannelManagerGetChannelWithAssociationsRequest) (*ChannelmanagerChannelResponseWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerChannelResponseWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerGetChannelWithAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/GetChannelWithAssociations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerGetMarketRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerGetMarketRequest
}

func (r ChannelManagerAPIChannelManagerGetMarketRequest) Body(body ChannelmanagerGetMarketRequest) ChannelManagerAPIChannelManagerGetMarketRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerGetMarketRequest) Execute() (*ChannelmanagerMarketResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerGetMarketExecute(r)
}

/*
ChannelManagerGetMarket GetMarket

Get an existing market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerGetMarketRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerGetMarket(ctx context.Context) ChannelManagerAPIChannelManagerGetMarketRequest {
	return ChannelManagerAPIChannelManagerGetMarketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerMarketResponse
func (a *ChannelManagerAPIService) ChannelManagerGetMarketExecute(r ChannelManagerAPIChannelManagerGetMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerGetMarket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/GetMarket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerGetMarketWithAssociationsRequest
}

func (r ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest) Body(body ChannelmanagerGetMarketWithAssociationsRequest) ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest) Execute() (*ChannelmanagerMarketResponseWithAssociations, *http.Response, error) {
	return r.ApiService.ChannelManagerGetMarketWithAssociationsExecute(r)
}

/*
ChannelManagerGetMarketWithAssociations GetMarketWithAssociations

Get an existing market with associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerGetMarketWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest {
	return ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerMarketResponseWithAssociations
func (a *ChannelManagerAPIService) ChannelManagerGetMarketWithAssociationsExecute(r ChannelManagerAPIChannelManagerGetMarketWithAssociationsRequest) (*ChannelmanagerMarketResponseWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerMarketResponseWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerGetMarketWithAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/GetMarketWithAssociations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerListChannelsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerListChannelsRequest
}

func (r ChannelManagerAPIChannelManagerListChannelsRequest) Body(body ChannelmanagerListChannelsRequest) ChannelManagerAPIChannelManagerListChannelsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerListChannelsRequest) Execute() (*ChannelmanagerListChannelsResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerListChannelsExecute(r)
}

/*
ChannelManagerListChannels ListChannels

List all channels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerListChannelsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerListChannels(ctx context.Context) ChannelManagerAPIChannelManagerListChannelsRequest {
	return ChannelManagerAPIChannelManagerListChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerListChannelsResponse
func (a *ChannelManagerAPIService) ChannelManagerListChannelsExecute(r ChannelManagerAPIChannelManagerListChannelsRequest) (*ChannelmanagerListChannelsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerListChannelsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerListChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/ListChannels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerListChannelsWithAssociationsRequest
}

func (r ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest) Body(body ChannelmanagerListChannelsWithAssociationsRequest) ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest) Execute() (*ChannelmanagerListChannelsWithAssociationsResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerListChannelsWithAssociationsExecute(r)
}

/*
ChannelManagerListChannelsWithAssociations ListChannelsWithAssociations

List all channels with associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerListChannelsWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest {
	return ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerListChannelsWithAssociationsResponse
func (a *ChannelManagerAPIService) ChannelManagerListChannelsWithAssociationsExecute(r ChannelManagerAPIChannelManagerListChannelsWithAssociationsRequest) (*ChannelmanagerListChannelsWithAssociationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerListChannelsWithAssociationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerListChannelsWithAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/ListChannelsWithAssociations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerListMarketsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerListMarketsRequest
}

func (r ChannelManagerAPIChannelManagerListMarketsRequest) Body(body ChannelmanagerListMarketsRequest) ChannelManagerAPIChannelManagerListMarketsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerListMarketsRequest) Execute() (*ChannelmanagerListMarketsResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerListMarketsExecute(r)
}

/*
ChannelManagerListMarkets ListMarkets

List all markets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerListMarketsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerListMarkets(ctx context.Context) ChannelManagerAPIChannelManagerListMarketsRequest {
	return ChannelManagerAPIChannelManagerListMarketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerListMarketsResponse
func (a *ChannelManagerAPIService) ChannelManagerListMarketsExecute(r ChannelManagerAPIChannelManagerListMarketsRequest) (*ChannelmanagerListMarketsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerListMarketsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerListMarkets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/ListMarkets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerListMarketsWithAssociationsRequest
}

func (r ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest) Body(body ChannelmanagerListMarketsWithAssociationsRequest) ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest) Execute() (*ChannelmanagerListMarketsWithAssociationsResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerListMarketsWithAssociationsExecute(r)
}

/*
ChannelManagerListMarketsWithAssociations ListMarketsWithAssociations

List all markets with associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerListMarketsWithAssociations(ctx context.Context) ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest {
	return ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerListMarketsWithAssociationsResponse
func (a *ChannelManagerAPIService) ChannelManagerListMarketsWithAssociationsExecute(r ChannelManagerAPIChannelManagerListMarketsWithAssociationsRequest) (*ChannelmanagerListMarketsWithAssociationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerListMarketsWithAssociationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerListMarketsWithAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/ListMarketsWithAssociations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerUpdateChannelRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerUpdateChannelRequest
}

func (r ChannelManagerAPIChannelManagerUpdateChannelRequest) Body(body ChannelmanagerUpdateChannelRequest) ChannelManagerAPIChannelManagerUpdateChannelRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerUpdateChannelRequest) Execute() (*ChannelmanagerChannelResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerUpdateChannelExecute(r)
}

/*
ChannelManagerUpdateChannel UpdateChannel

Update an existing channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerUpdateChannelRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerUpdateChannel(ctx context.Context) ChannelManagerAPIChannelManagerUpdateChannelRequest {
	return ChannelManagerAPIChannelManagerUpdateChannelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerChannelResponse
func (a *ChannelManagerAPIService) ChannelManagerUpdateChannelExecute(r ChannelManagerAPIChannelManagerUpdateChannelRequest) (*ChannelmanagerChannelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerChannelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerUpdateChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/UpdateChannel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelManagerAPIChannelManagerUpdateMarketRequest struct {
	ctx context.Context
	ApiService ChannelManagerAPI
	body *ChannelmanagerUpdateMarketRequest
}

func (r ChannelManagerAPIChannelManagerUpdateMarketRequest) Body(body ChannelmanagerUpdateMarketRequest) ChannelManagerAPIChannelManagerUpdateMarketRequest {
	r.body = &body
	return r
}

func (r ChannelManagerAPIChannelManagerUpdateMarketRequest) Execute() (*ChannelmanagerMarketResponse, *http.Response, error) {
	return r.ApiService.ChannelManagerUpdateMarketExecute(r)
}

/*
ChannelManagerUpdateMarket UpdateMarket

Update an existing market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelManagerAPIChannelManagerUpdateMarketRequest
*/
func (a *ChannelManagerAPIService) ChannelManagerUpdateMarket(ctx context.Context) ChannelManagerAPIChannelManagerUpdateMarketRequest {
	return ChannelManagerAPIChannelManagerUpdateMarketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelmanagerMarketResponse
func (a *ChannelManagerAPIService) ChannelManagerUpdateMarketExecute(r ChannelManagerAPIChannelManagerUpdateMarketRequest) (*ChannelmanagerMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelmanagerMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelManagerAPIService.ChannelManagerUpdateMarket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channelmanager.ChannelManager/UpdateMarket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
